---
title: The JavaScript Environment Part Three - Closures
date: 2020-08-10
---

This is part three of a five part series I've written to assist in my learning, and also to help anyone else out there facing similar struggles. Check out the other parts of this series:

1. <Link to='/posts/javascript-environment-part-one'>Overview</Link>
2. <Link to='/posts/javascript-environment-part-two'>JavaScript engines</Link>
3. Closures
4. <Link to='/posts/javascript-environment-part-four'>Browser engines</Link>
5. <Link to='/posts/javascript-environment-part-five'>Asynchronous Operations</Link>

## Closures

Every time a function is defined, it creates a new lexical environment. Every lexical environment keeps a reference to the environment it was created in. In other words, every time a function is invoked, it has access to all identifiers in scope at the time of its definition&mdash;even if invoked after the scope in which it was defined is no longer on the call stack. Together, these two facts result in what is known as a closure. 

### Using Closures with Callbacks

Callback functions are called after some asynchronous operation has completed, in which case the execution context and lexical environment they were defined in will no longer be on the stack. 

Because the callback function creates a closure, its still possible to access variables defined outside its lexical environment. 

```
var tick = 0;
var timer = setInterval(function(){
  if(tick < 8){
    console.log(tick);
  }
  tick++;
}, 1000)
```

In this example, `tick` is still in scope despite the callback function being the only function on the call stack. 

### Using Closures to Create Private Variables

Every time a constructor is invoked using the `new` keyword, a new lexical environment is assigned to it to track variables local to the constructor. Because of this, we can declare variables inside the constructor that are only accessible in the scope of the constructor, thus acting as private variables. 

Functions defined as methods have access to the scope in which they were defined, which creates a closure around those private variables. As a result, methods can mutate the private variables associated with a particular object. 

These variables cannot be accessed directly, as they are not connected to the context of newly initiated objects; they can only be accessed through the closure. 

```
function Counter(){
  var count = 0;
  this.getCount = function(){
    return count;
  }
  this.increment = function(){
    count++;
  }
}
```

In this example, the `Counter()` constructor has a private variable `count` only available in its scope. This variable cannot be accessed directly; it must be accessed through the two methods provided in the constructor. 

Note though, that because these private variables rely on closures, its possible access them through other objects. 

```
var counterA = new Counter();
var counterB = {};
counterB.getCount = counterA.getCount;
console.log(counterB.getCount()) // logs the count of counterA
```

In this example, `counterB` has access to the count of `counterA` because it is given a reference to the `getCount()` method, which has access to the `count` variable through the closure. 