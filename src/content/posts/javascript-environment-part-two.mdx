---
title: The JavaScript Environment Part Two - JavaScript Engines
date: 2020-08-09
---

This is part two of a five part series I've written to assist in my learning, and also to help anyone else out there facing similar struggles. Check out the other parts of this series:

1. <Link to='/posts/javascript-environment-part-one'>Overview</Link>
2. JavaScript Engines
3. <Link to='/posts/javascript-environment-part-three'>Closures</Link>
4. <Link to='/posts/javascript-environment-part-four'>Browser engines</Link>
5. <Link to='/posts/javascript-environment-part-five'>Asynchronous Operations</Link>

## JavaScript Engines

JavaScript engines consist of four main components:
- The heap, or **global memory**
- Lexical environments
- Execution contexts
- The execution context stack, or **call stack**
- Task queues

### The Heap

The heap contains references to all function declarations and variables. It is more commonly referred to as global memory. 

### Lexical Environments

[Lexical environments](https://www.ecma-international.org/ecma-262/#sec-lexical-environments) are essentially the internal implementation of scopes, as they are always associated with syntactic structures such as function declarations and block statements. More specifically, they are used in **identifier resolution**, the process of mapping (registering) identifiers (variable or function names) to variables (memory locations). 

There are three subclasses of lexical environments to provide support for specialized environments:
- **global environment:** Sets the outer lexical environment's reference to `null`
- **function environment:** Provides `this` binding and provides support for `super` invocations
- **module environment:** Provides bindings for the top level declarations and imports in modules

**Note:** Double bracket notation is used to refer to an internal property that cannot be accessed. 

Each lexical environment contains:
- An internal `[[Environmental Record]]` property that records all identifier bindings in the environment. 
- A reference to the Environmental Record of the current environment's outer environment. 

Environmental Records are necessary because the JavaScript engine must be able to access identifiers declared outside the current environment during identifier resolution. If an identifier is not found in the current environment, the outer environment must be searched through the current environment's internal reference to it. 

There are two primary Environmental Record types:
- **declarative Environmental Records:** Used to bind identifiers of variables and functions
- **object Environmental Records:** Used to bind identifiers of object properties

In addition, there are three specialized Environmental Record types to provide support for the three specialized lexical environment subclasses:
- **global Environmental Records:** provides binding for built-in globals, properties of the global object, and all top-level declarations
- **function Environmental Records:** A subclass of declarative Environmental Records that provides `this` binding and contains the state used for `super` invocations
- **module Environmental Records:** A subclass of declarative Environmental Records that provides bindings for the top level declarations and imports in modules

### Execution Contexts

[Execution contexts](https://www.ecma-international.org/ecma-262/#sec-execution-contexts) are used with the call stack to track application execution. 

There are two types of code in JavaScript: 
- global code
- function code

There also two types of execution contexts, or the contexts code is executed in:
- global execution context: The execution context for all global code. There is only one global execution context per JavaScript program. 
- function execution context: The execution contexts created in the global execution context on each function invocation. 

**Note:** In the case of web browsers, there is one global execution context per web page. 

Execution contexts are also used in identifier resolution, because each execution context contains two associated lexical environments:
- LexicalEnvironment: contains all identifier bindings for function declarations, `let`, and `const`
- VariableEnvironment: contains all identifier bindings for `var`

### The Execution Context Stack

When a function is invoked, the current execution context must be stopped and a new execution context must be created. Once this execution context has completed, it is discarded and the original execution context resumes where it left off. The [execution context stack](https://www.ecma-international.org/ecma-262/#execution-context-stack) tracks these execution contexts to ensure application execution pauses and resumes correctly when functions are invoked or return. 

**Note:** There is only one execution context stack due to the single threaded execution model in JavaScript applications. 

The execution context stack is more commonly referred to as the **call stack**. 

### Macrotask and Microtask Queues

The components of JavaScript engines up to this point only account for synchronous behavior, but asynchronous operations return callback functions with their own function execution contexts. JavaScript engines must collect and handle the order that these callbacks are added to the call stack. 

To handle this, by ECMA Standards, JavaScript engines must maintain at least two task queues:

- **Macrotasks:** Used for executing large tasks like global JavaScript code, as well as low priority asynchronous operations like IO events and some API callbacks
  - examples: `setTimeout()` and `setInterval()`

- **Microtasks:** Used for executing smaller tasks that update the application state like callbacks in promises. Microtasks execute as soon as possible, before UI re-renders
  - examples: Promise callbacks

**Notes:** 
- In ECMAScript standards these are referred to has the [ScriptJobs and PromiseJobs](https://www.ecma-international.org/ecma-262/#sec-jobs-and-job-queues) queues, respectively. 
- Microtasks and Macrotasks queues are only the minimum required queues. Many JavaScript engines have even more queues divided up for specific types of macrotasks and microtasks.

### JavaScript Execution

JavaScript is an interpreted language; to match ECMAScript standards, its execution must run line by line. Some JavaScript engines may use hybrid optimization techniques such as *Just In Time* (JIT) compilation, an optimization technique that involved compiling each line of JavaScript to machine code the moment before execution, but still, it is inherently an interpreted language. 

This is because JavaScript execution must take place in two phases, as opposed to immediately executing as in a compiled language:

1. The identifier resolution phase
2. The execution phase

#### The Identifier Resolution Phase

**Recall:** Identifier resolution is the process of mapping (registering) identifiers (variable or function names) to variables (memory locations). 

The identifier resolution process takes place every time a new lexical environment is created. In this phase, the JavaScript engine registers all declared functions and identifiers. 

1. Create the Lexical Environment
2. If the environment is a function or global environment:
   - Scan the environment for function declarations:
     - Register the identifiers of function declarations that are outside other functions, and define their corresponding functions
     - If an identifier already exists in the outer environment, overwrite it
3. Scan the environment for variable declarations:
   - If the environment is a block environment:
     - Register identifiers of variables declared with `let` and `const` in the current block, but do not initialize them
       - If an identifier already exists in the outer environment, overwrite it
   - If the environment is a function or global environment:
     - Register the identifiers of variables declared with `var` outside other functions, and initialize them as `undefined`
       - If an identifier already exists in the current environment, overwrite it
     - Register the identifiers of variables declared with `let` and `const` outside blocks, but do not initialize them
       - If an identifier already exists in the current environment, throw a `SyntaxError`, as variables declared with `let` and `const` cannot be re-declared

##### Variable Declarations

- `const`: 
  - cannot be re-declared
  - cannot be reassigned
  - can be modified
  - must be initialized on definition
  - block, loop, function, or global scope
- `let`: 
  - cannot be re-declared
  - can be reassigned
  - can be modified
  - block, loop, function, or global scope
- `var`: 
  - can be re-declared
  - can be reassigned
  - can be modified
  - function or global scope

##### A Note on "Undeclared Variables"

"Undeclared Variables", as they are often called, are variables that appear to have been registered without any variable declaration:

`foo = null`

These variables are actually properties of the global object, which is defined by the global Environmental Record. As such, they are treated as object properties by the JavaScript engine. 

#### The Execution Phase

The execution phase begins only once the identifier resolution phase is complete, and consists of the actual line by line execution of JavaScript code. 

#### Effects of the JavaScript Execution Model

##### Hoisting

The identifier resolution phase registers variables and function declarations before the execution phase. This is often referred to as *hoisting*, because it is as if the declarations are being hoisted to the top of the environment before execution. 

As a result, variables declared with `var` and function declarations can be accessed before their declarations because functions are defined on registration, and variables declared with `var` are initialized as `undefined` on their registration. 

```
console.log(foo); // logs the function
console.log(bar); // logs undefined

function foo() {};
var bar = null;
```

In this example, both `foo` and `bar` can be accessed before their declaration. 

Variables `let` and `const`, however, behave differently. Unlike `var`, they are never initialized as `undefined` on registration; but rather are let uninitialized until the execution phase. 

```
console.log(foo); // logs the function
console.log(bar); // throws a reference error

function foo() {};
let bar = null;
```

Unlike the previous example, this example will throw a `ReferenceError` because `bar` is accessed before its initialization. 

ECMAScript standards explicitly state [let and const](https://www.ecma-international.org/ecma-262/#sec-let-and-const-declarations) "may not be accessed in any way until the variable's LexicalBinding is evaluated."

This restriction results in a zone between the declaration of variables declared with `let` or `const` and the top of the environment which is known as the *Temporal Dead Zone* (TDZ). 

The TDZ exists to ensure variables declared with `const` cannot be mutated as variables declared with `var` can, because this would violate their entire purpose. Variables declared with `let` only have the TDZ for consistency, as both are block scoped. 

##### Overriding Function Declarations

Variables declared with `var` are only initialized as `undefined` in step three of the identifier resolution process if they have not been encountered in the environment. If a variable is declared with `var` but has the same identifier as a function declaration, the variable will already have been encountered because function declarations are registered before variables in step two of the identifier resolution process. As a result, the variable will not be initialized as undefined; instead, it will retain its value, the function, until the variable is re-initialized. 

```
console.log(foo); // logs the function
var foo = null;
function foo(){}
console.log(foo); // logs null
```

In this example, the identifier `foo` is registered and assigned a reference to a function declaration in step two of the identifier resolution process. In step three, it is not set to undefined because the identifier `foo` already exists in the environment; instead, it is left with the function `foo` assigned as its reference until it is re-initialized by the var declaration. This reassignment causes the function declaration's reference to be lost, and thus overridden. 

This same behavior can be accomplished by simply re-initializing `foo`:

```
console.log(foo); // logs the function
foo = null;
function foo(){}
console.log(foo); // logs null
```

But not by simply re-declaring `foo`: 

```
console.log(foo); // logs the function
var foo;
function foo(){}
console.log(foo); // logs the function
```

Because the identifier `foo` is never re-initialized, it retains its reference to the function declaration and is not overridden. 

**Note:** Function declarations can only be overridden with `var` or by simply re-initializing the identifier. Using `let` or `const` will result in a `SyntaxError` because `let` and `const` cannot be re-declared from any other variable. 

### Popular Browsers and their JavaScript Engines

- Chromium / Google Chrome: V8
- Microsoft Edge: V8
- Mozilla Firefox: SpiderMonkey
- Safari: Nitro
