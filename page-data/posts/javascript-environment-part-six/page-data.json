{"componentChunkName":"component---src-components-mdx-layout-index-js","path":"/posts/javascript-environment-part-six/","result":{"data":{"mdx":{"id":"81e34c32-f8f7-5dbf-a6df-99a0aee29085","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"The JavaScript Environment Part Six - Asynchronous Operations\",\n  \"description\": \"For this final part I'll be discussing another special topic: asynchronous operations. I'll explain what they really are in the context...\",\n  \"date\": \"2020-08-13T00:00:00.000Z\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Link = makeShortcode(\"Link\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This is part six of a six part series I\\u2019ve written to assist in my learning, and also to help anyone else out there facing similar struggles.\\nCheck out the other parts of this series:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(Link, {\n    to: \"/posts/javascript-environment-part-one\",\n    mdxType: \"Link\"\n  }, \"Overview\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(Link, {\n    to: \"/posts/javascript-environment-part-two\",\n    mdxType: \"Link\"\n  }, \"JavaScript Engines\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(Link, {\n    to: \"/posts/javascript-environment-part-three\",\n    mdxType: \"Link\"\n  }, \"Browser Engines\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(Link, {\n    to: \"/posts/javascript-environment-part-four\",\n    mdxType: \"Link\"\n  }, \"JavaScript Execution\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(Link, {\n    to: \"/posts/javascript-environment-part-five\",\n    mdxType: \"Link\"\n  }, \"Closures\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Asynchronous Operations\")), mdx(\"h2\", {\n    \"id\": \"asynchronous-operations\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#asynchronous-operations\",\n    \"aria-label\": \"asynchronous operations permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Asynchronous Operations\"), mdx(\"p\", null, \"For this final part I\\u2019ll be discussing another special topic: asynchronous operations.\\nI\\u2019ll explain what they really are in the context of everything I\\u2019ve covered so far in this series,\\nand then I\\u2019ll show their two most common use cases.\"), mdx(\"p\", null, \"Time for one last review. Here are the important concepts to remember: \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"JavaScript applications use a single threaded execution model, so any long running operation on the call stack will block the UI from updating. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Thankfully, most long running operations don\\u2019t run on the call stack; they run asynchronously through Web APIs built into the browser.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Web APIs can be accessed by calling asynchronous JavaScript functions which are immediately removed from the call stack.\")), mdx(\"p\", null, \"Alright now here\\u2019s where asynchronous operations come into the picture.\\nWeb APIs do not run on the call stack, so there\\u2019s no way for us to know when they have completed their asynchronous task unless they provide us with one.\\nThis is the origin of callbacks, promises, and async / await.\\nThey are each a way for us developers to write code that will run when some Web API completes its asynchronous task.\"), mdx(\"h3\", {\n    \"id\": \"callback-functions\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#callback-functions\",\n    \"aria-label\": \"callback functions permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Callback Functions\"), mdx(\"p\", null, \"Most Web APIs written before ES2015 handle asynchronous operations through callback functions.\\nA callback function is just a functions passed into another function as an argument that will be \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"called back\"), \" at a later point in time. \"), mdx(\"p\", null, \"The following examples use JQuery\\u2019s \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getJSON()\"), \" function, which is actually just a wrapper around a Web API:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"$.getJSON(\\\"./example.json\\\", function(){\\n  // handle results \\n});\\n\")), mdx(\"p\", null, \"Unfortunately the callback method has many problems, namely the following:\"), mdx(\"h4\", {\n    \"id\": \"error-handling\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#error-handling\",\n    \"aria-label\": \"error handling permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Error handling\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"try {\\n  $.getJSON(\\\"./example.json\\\", function(result){\\n    const data = JSON.parse(result);\\n  });\\n} catch(error){\\n  // handle errors\\n}\\n\")), mdx(\"p\", null, \"In this block, the callback function is called on an entirely different iteration of the event loop and is the only function on the call stack.\\nIf an error is thrown within it, for example from the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JSON.parse()\"), \" call, the catch block will not be called and the error will be lost!\"), mdx(\"h4\", {\n    \"id\": \"the-pyramid-of-doom\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#the-pyramid-of-doom\",\n    \"aria-label\": \"the pyramid of doom permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"The Pyramid of Doom\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"$.getJSON(\\\"./example1.json\\\", function(){\\n  $.getJSON(\\\"./example2.json\\\", function(){\\n    $.getJSON(\\\"./example3.json\\\", function(){\\n      // handle results \\n    });\\n  });\\n});\\n\")), mdx(\"p\", null, \"Calling asynchronous functions in the callback of other asynchronous function can also result in some \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"very\"), \" difficult code. \"), mdx(\"h4\", {\n    \"id\": \"running-asynchronous-functions-in-parallel\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#running-asynchronous-functions-in-parallel\",\n    \"aria-label\": \"running asynchronous functions in parallel permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Running Asynchronous Functions in Parallel\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"$.getJSON(\\\"./example1.json\\\", function(){\\n  // handle results \\n});\\n$.getJSON(\\\"./example2.json\\\", function(){\\n  // handle results \\n});\\n$.getJSON(\\\"./example3.json\\\", function(){\\n  // handle results \\n});\\n\")), mdx(\"p\", null, \"In this case, there is no way to know when all the Web APIs have completed their task.\\nIf there is some operation that should be completed after all tasks have successfully completed,\\nthe only way to know when it should run would be to check if every asynchronous function has returned in every callback. This could get \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"very\"), \" tedious!\"), mdx(\"h3\", {\n    \"id\": \"promises\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#promises\",\n    \"aria-label\": \"promises permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Promises\"), mdx(\"p\", null, \"Web APIs written after ES2015 handle asynchronous operations by returning a promise. \"), mdx(\"p\", null, \"A promise is a placeholder object for a value that doesn\\u2019t exist, but might in the future.\\nIf the promise is kept, its result will be a value. Otherwise, its result will be an error. \"), mdx(\"h4\", {\n    \"id\": \"creating-promises\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#creating-promises\",\n    \"aria-label\": \"creating promises permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Creating promises\"), mdx(\"p\", null, \"To really understand promises, it\\u2019s important to look at them from the perspective of a developer writing an API that utilizes Web APIs.\\nYou can probably imagine how you might write such an API based on callbacks; just take a function as a parameter and execute it once the Web API completes its task.\\nA promise-based API is a little more complicated. It has to return a promise object, so it\\u2019s time to go over how promises are created in the first place.\"), mdx(\"p\", null, \"The promise constructor takes a single function called the executor function as a parameter.\\nThe executor function takes two functions called resolve and reject as parameters, and calls these functions to change the state of the promise.\"), mdx(\"p\", null, \"Promises have three states:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"pending, or unresolved state: The value is completely unknown. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"fulfilled state: The promise\\u2019s \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"resolve()\"), \" function has been called and the promised value has been returned. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"rejected state: \", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The promise\\u2019s \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"reject()\"), \" function has been called\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"an unhandled exception occurred\")))), mdx(\"p\", null, \"A simple promise that does nothing but resolve immediately and has no rejection cases:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"const promise = new Promise((resolve, reject) => {\\n  resolve(\\\"result\\\");\\n  // reject(\\\"error\\\");\\n});\\n\\n\")), mdx(\"h4\", {\n    \"id\": \"using-promises\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#using-promises\",\n    \"aria-label\": \"using promises permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Using promises\"), mdx(\"p\", null, \"Promises are used by calling their built in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"then()\"), \" method. This method takes two functions:\\none for if the promise is fulfilled, and another for if it\\u2019s rejected.\"), mdx(\"p\", null, \"The promise is fulfilled if its \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"resolve()\"), \" function is called in the executor function.\"), mdx(\"p\", null, \"The promise can be rejected in two ways: \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Explicitly: if its \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"reject()\"), \" function is called in the executor function\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Implicitly: if an unhandled exception occurs, for example an undeclared variable \")), mdx(\"p\", null, \"In either of these circumstances, the reject callback of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"then()\"), \" function will be called. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"promise.then(result => {\\n  console.log(result);\\n}, error => {\\n  console.log(error);\\n});\\n\")), mdx(\"p\", null, \"The function passed to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"then()\"), \" method is added to the microtask queue, so it is run after all code in the current step of the event loop has completed.\"), mdx(\"h4\", {\n    \"id\": \"converting-older-web-apis-into-promise-based-apis\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#converting-older-web-apis-into-promise-based-apis\",\n    \"aria-label\": \"converting older web apis into promise based apis permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Converting older Web APIs into promise based APIs\"), mdx(\"p\", null, \"The setTimeout Web API uses callbacks to handle its asynchronous operation. Fortunately, we can wrap it in a promise to make it easier to work with:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"function setTimeoutPromise(time) {\\n  return new Promise((resolve, reject) => {\\n    id = setTimeout(() => {\\n      resolve(id);\\n    }, time);\\n  });\\n}\\n\\nsetTimeoutPromise(1000).then(id => {\\n  console.log(id);\\n});\\n\")), mdx(\"h4\", {\n    \"id\": \"chaining-promises\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#chaining-promises\",\n    \"aria-label\": \"chaining promises permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Chaining promises\"), mdx(\"p\", null, \"One particularly useful feature of promises is the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"then()\"), \" method always returns a new promise!\\nEven if the value in its resolve function is not a promise, that value is automatically wrapped in one.\\nThis actually ends up being extremely useful.\\nWhenever a future promise depends on the success of a previous promise, just chain the promises together to run one after another.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"getJSON(data/resultA.json)\\n  .then(resultA => getJSON(data/resultB.json))\\n  .then(resultB => console.log(\\\"completed chain\\\"))\\n  .catch(error => console.log(error));\\n\")), mdx(\"p\", null, \"You can even catch all errors at once by using a catch statement at the end of the chain. If there\\u2019s an error at any point, it will be invoked.\\nYou can also use a catch statement for single promises, but this is entirely up to personal preference. \"), mdx(\"h4\", {\n    \"id\": \"waiting-for-a-number-of-promises\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#waiting-for-a-number-of-promises\",\n    \"aria-label\": \"waiting for a number of promises permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Waiting for a number of promises\"), mdx(\"p\", null, \"If the order the promises are completed in doesn\\u2019t matter, just use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Promise.all()\"), \" method.\\nThis method takes an array of function callbacks, and returns a new promise that fulfills or rejects only if all promises are fulfilled.\\nIts \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"then()\"), \" function receives an array of all the results.\"), mdx(\"p\", null, \"If only the first promise to be completed matters, call the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Promise.race()\"), \" method.\\nIt operates in the same way as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Promise.all()\"), \", except it returns a new promise that fulfills or rejects based only on the first promise to fulfill or reject.\\nIts \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"then()\"), \" function of course returns only the first result.\"), mdx(\"h3\", {\n    \"id\": \"asyncawait\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h3\",\n    \"href\": \"#asyncawait\",\n    \"aria-label\": \"asyncawait permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Async/Await\"), mdx(\"p\", null, \"Promises are much better than callback functions, but they still have issues.\\nThe ES2017 \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"async\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"await\"), \" keywords solve many of these issues by making it possible to write asynchronous code in a synchronous way!\"), mdx(\"p\", null, \"Internally, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"async\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"await\"), \" basically combine promises with ES2015 generator functions,\\na special type of function that makes it possible to pause a function\\u2019s execution without blocking the call stack.\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"async\"), \" keyword defines the function as an asynchronous function,\\nand the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"await\"), \" keyword followed by an asynchronous operation that returns a promise\\ncreates an expression that pauses the function\\u2019s execution until the promise is resolved.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"function setTimeoutPromise(time) {\\n  return new Promise((resolve, reject) => {\\n    id = setTimeout(() => {\\n      resolve(id);\\n    }, time);\\n  });\\n}\\n\\nasync function doubleTimeout(time) { \\n  firstId = await setTimeoutPromise(time);\\n  secondId = await setTimeoutPromise(time);\\n  return [firstId, secondId];\\n};\\n\")), mdx(\"h4\", {\n    \"id\": \"error-handling-1\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#error-handling-1\",\n    \"aria-label\": \"error handling 1 permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Error handling\"), mdx(\"p\", null, \"Promises don\\u2019t just result in slightly messier code, they actually have the same error handling problems that callback functions have!\\nOnce again, the function in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"then()\"), \" method is called on an entirely different iteration of the event loop at which point it is the only function on the call stack.\\nIf an error is thrown within it, the catch block will not be called and the error will be lost. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"function getJSONPromise(path) {\\n  return new Promise((resolve, reject) => {\\n    $.getJSON(() => {\\n      resolve(path);\\n    });\\n  });\\n}\\n\\ntry {\\n  getJSONPromise(\\\"./example.json\\\")\\n    .then(function(result) {\\n      const data = JSON.parse(result);\\n    });\\n} catch(error){\\n  // handle errors\\n}\\n\")), mdx(\"p\", null, \"With \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"async\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"await\"), \" the catch statement will finally catch the error!\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"async function getJSONAsync() {\\n  try {\\n    const data = JSON.parse(await $.getJSON());\\n  }\\n  catch(error) {\\n    console.log(error);\\n  }\\n}\\n\")), mdx(\"h4\", {\n    \"id\": \"error-reporting\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#error-reporting\",\n    \"aria-label\": \"error reporting permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Error Reporting\"), mdx(\"p\", null, \"Error handling isn\\u2019t the only issue solved by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"async\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"await\"), \". \"), mdx(\"p\", null, \"Promises report all errors, even those within the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"then()\"), \" method, as originating within the promise itself.\\nThis makes it very difficult to track down where an error originates from because a function\\nthat returns a new promise could be called throughout the code base and handle errors differently each time. \"), mdx(\"p\", null, \"In async functions, errors are reported as coming from the function where they originate!\"), mdx(\"h4\", {\n    \"id\": \"syntax\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h4\",\n    \"href\": \"#syntax\",\n    \"aria-label\": \"syntax permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Syntax\"), mdx(\"p\", null, \"Async functions improve syntax significantly over promises:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"conditionally chained promises do not require nested \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"then()\"), \" calls like promise chains do\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"synchronously called async operations do not need complicated \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"then()\"), \" calls like promise chains do\")), mdx(\"h2\", {\n    \"id\": \"conclusions\",\n    \"style\": {\n      \"position\": \"relative\"\n    }\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"#conclusions\",\n    \"aria-label\": \"conclusions permalink\",\n    \"className\": \"anchor before\"\n  }, mdx(\"svg\", {\n    parentName: \"a\",\n    \"aria-hidden\": \"true\",\n    \"focusable\": \"false\",\n    \"height\": \"16\",\n    \"version\": \"1.1\",\n    \"viewBox\": \"0 0 16 16\",\n    \"width\": \"16\"\n  }, mdx(\"path\", {\n    parentName: \"svg\",\n    \"fillRule\": \"evenodd\",\n    \"d\": \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"\n  }))), \"Conclusions\"), mdx(\"p\", null, \"Alright we\\u2019re done!\\nThe concepts I covered in this series are just what I found most confusing entering the complex world of web development.\\nMy research is not always perfect and there\\u2019s always more out there to learn,\\nso please feel free to contact me if you notice any mistakes or\\nhave any suggestions of topics you feel belong in this series\\u2014I might add additional parts someday.\"), mdx(\"p\", null, \"I hope you enjoyed reading these articles as much as I did researching and writing them!\"));\n}\n;\nMDXContent.isMDXComponent = true;","fileAbsolutePath":"/home/lee/projects/gatsby/data-viz-portfolio/src/content/posts/javascript-environment-part-six.mdx","frontmatter":{"title":"The JavaScript Environment Part Six - Asynchronous Operations","description":"For this final part I'll be discussing another special topic: asynchronous operations. I'll explain what they really are in the context...","date":"August 13, 2020"}}},"pageContext":{"id":"81e34c32-f8f7-5dbf-a6df-99a0aee29085"}},"staticQueryHashes":["2865337466","63159454"]}