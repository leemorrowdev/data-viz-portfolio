{"componentChunkName":"component---src-templates-mdx-index-js","path":"/posts/javascript-environment-part-five/","result":{"data":{"mdx":{"id":"579ac86d-3d11-55d1-b361-6dd7aaf92eee","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"The JavaScript Environment Part Five - Closures\",\n  \"date\": \"2020-08-12T00:00:00.000Z\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Link = makeShortcode(\"Link\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This is part five of a six part series I\\u2019ve written to assist in my learning, and also to help anyone else out there facing similar struggles.\\nCheck out the other parts of this series:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(Link, {\n    to: \"/posts/javascript-environment-part-one\",\n    mdxType: \"Link\"\n  }, \"Overview\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(Link, {\n    to: \"/posts/javascript-environment-part-two\",\n    mdxType: \"Link\"\n  }, \"JavaScript Engines\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(Link, {\n    to: \"/posts/javascript-environment-part-three\",\n    mdxType: \"Link\"\n  }, \"Browser Engines\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(Link, {\n    to: \"/posts/javascript-environment-part-four\",\n    mdxType: \"Link\"\n  }, \"JavaScript Execution\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Closures\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(Link, {\n    to: \"/posts/javascript-environment-part-six\",\n    mdxType: \"Link\"\n  }, \"Asynchronous Operations\"))), mdx(\"h2\", null, \"Closures\"), mdx(\"p\", null, \"In this part I\\u2019ll be discussing a special topic: closures. I\\u2019ll explain what they really are in the context of everything I\\u2019ve covered so far in this series,\\nand then I\\u2019ll show their two most common use cases.\"), mdx(\"p\", null, \"First, its review time again. We know that every time a function is defined, it creates a new lexical environment.\\nWe also know that every lexical environment keeps a reference to the environment it was created in. \"), mdx(\"p\", null, \"Alright now here\\u2019s the new part:\"), mdx(\"p\", null, \"In other words, every time a function is invoked it has access to all identifiers in scope at the time of its definition\", \"\\u2014\", \"\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"even if it is invoked after the scope in which it was defined is no longer on the call stack.\"), \" \"), mdx(\"p\", null, \"This results in what is known as a closure.\\nThe variables in scope when the function was defined are \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"enclosed\"), \" around that function, such that they can be accessed at a later time.\"), mdx(\"h3\", null, \"Using Closures with Callbacks\"), mdx(\"p\", null, \"Callback functions are functions that are called after some asynchronous operation has completed,\\nat which point the execution context and lexical environment they were defined in will no longer be on the call stack. \"), mdx(\"p\", null, \"Because the callback function creates a closure when it is defined, its still possible to access variables defined outside its lexical environment. \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"var tick = 0;\\nvar timer = setInterval(function(){\\n  if(tick < 8){\\n    console.log(tick);\\n  }\\n  tick++;\\n}, 1000)\\n\")), mdx(\"p\", null, \"In this example, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tick\"), \" is still in scope despite the callback function being the only function on the call stack. \"), mdx(\"h3\", null, \"Using Closures to Create Private Variables\"), mdx(\"p\", null, \"Every time a constructor is invoked using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"new\"), \" keyword, a new lexical environment is assigned to it to track variables local to the constructor.\\nBecause of this, we can declare variables inside the constructor that are only accessible in the scope of the constructor. Private variables in JavaScript! \"), mdx(\"p\", null, \"Functions defined as methods have access to the scope in which they were defined,\\nwhich creates a closure around those variables. We even have methods can mutate the private variables associated with a particular object!\"), mdx(\"p\", null, \"Again, these variables cannot be accessed directly because they are not connected to the context of newly initiated objects; they can only be accessed through the closure. \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"function Counter(){\\n  var count = 0;\\n  this.getCount = function(){\\n    return count;\\n  }\\n  this.increment = function(){\\n    count++;\\n  }\\n}\\n\")), mdx(\"p\", null, \"In this example, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Counter()\"), \" constructor has a private variable \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"count\"), \" only available in its scope.\\nThis variable cannot be accessed directly; it must be accessed through the two methods provided in the constructor. \"), mdx(\"p\", null, \"Note though, because these private variables rely on closures, it is possible to access them through other objects by accident. Be careful!\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"var counterA = new Counter();\\nvar counterB = {};\\ncounterB.getCount = counterA.getCount;\\nconsole.log(counterB.getCount()) // logs the count of counterA\\n\")), mdx(\"p\", null, \"In this example, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"counterB\"), \" has access to the count of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"counterA\"), \" because it is given a reference to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getCount()\"), \" method,\\nwhich has access to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"count\"), \" variable through the closure.\"), mdx(\"p\", null, \"See, you were probably already using closures all the time and you didn\\u2019t even realize it!\"));\n}\n;\nMDXContent.isMDXComponent = true;","fileAbsolutePath":"/home/lee/projects/gatsby/data-viz-portfolio/src/content/posts/javascript-environment-part-five.mdx","frontmatter":{"title":"The JavaScript Environment Part Five - Closures","date":"August 12, 2020"}}},"pageContext":{"id":"579ac86d-3d11-55d1-b361-6dd7aaf92eee"}}}