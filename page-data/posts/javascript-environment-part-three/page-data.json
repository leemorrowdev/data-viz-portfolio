{"componentChunkName":"component---src-templates-mdx-index-js","path":"/posts/javascript-environment-part-three/","result":{"data":{"mdx":{"id":"82149c5f-c3c7-5ede-9ea9-b1f07ffdd1b1","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"The JavaScript Environment Part Three - Closures\",\n  \"date\": \"2020-08-10T00:00:00.000Z\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Link = makeShortcode(\"Link\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This is part three of a five part series I\\u2019ve written to assist in my learning, and also to help anyone else out there facing similar struggles. Check out the other parts of this series:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(Link, {\n    to: \"/posts/javascript-environment-part-one\",\n    mdxType: \"Link\"\n  }, \"Overview\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(Link, {\n    to: \"/posts/javascript-environment-part-two\",\n    mdxType: \"Link\"\n  }, \"JavaScript engines\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Closures\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(Link, {\n    to: \"/posts/javascript-environment-part-four\",\n    mdxType: \"Link\"\n  }, \"Browser engines\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(Link, {\n    to: \"/posts/javascript-environment-part-five\",\n    mdxType: \"Link\"\n  }, \"Asynchronous Operations\"))), mdx(\"h2\", null, \"Closures\"), mdx(\"p\", null, \"Every time a function is defined, it creates a new lexical environment. Every lexical environment keeps a reference to the environment it was created in. In other words, every time a function is invoked, it has access to all identifiers in scope at the time of its definition\", \"\\u2014\", \"even if invoked after the scope in which it was defined is no longer on the call stack. Together, these two facts result in what is known as a closure. \"), mdx(\"h3\", null, \"Using Closures with Callbacks\"), mdx(\"p\", null, \"Callback functions are called after some asynchronous operation has completed, in which case the execution context and lexical environment they were defined in will no longer be on the stack. \"), mdx(\"p\", null, \"Because the callback function creates a closure, its still possible to access variables defined outside its lexical environment. \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"var tick = 0;\\nvar timer = setInterval(function(){\\n  if(tick < 8){\\n    console.log(tick);\\n  }\\n  tick++;\\n}, 1000)\\n\")), mdx(\"p\", null, \"In this example, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tick\"), \" is still in scope despite the callback function being the only function on the call stack. \"), mdx(\"h3\", null, \"Using Closures to Create Private Variables\"), mdx(\"p\", null, \"Every time a constructor is invoked using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"new\"), \" keyword, a new lexical environment is assigned to it to track variables local to the constructor. Because of this, we can declare variables inside the constructor that are only accessible in the scope of the constructor, thus acting as private variables. \"), mdx(\"p\", null, \"Functions defined as methods have access to the scope in which they were defined, which creates a closure around those private variables. As a result, methods can mutate the private variables associated with a particular object. \"), mdx(\"p\", null, \"These variables cannot be accessed directly, as they are not connected to the context of newly initiated objects; they can only be accessed through the closure. \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"function Counter(){\\n  var count = 0;\\n  this.getCount = function(){\\n    return count;\\n  }\\n  this.increment = function(){\\n    count++;\\n  }\\n}\\n\")), mdx(\"p\", null, \"In this example, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Counter()\"), \" constructor has a private variable \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"count\"), \" only available in its scope. This variable cannot be accessed directly; it must be accessed through the two methods provided in the constructor. \"), mdx(\"p\", null, \"Note though, that because these private variables rely on closures, its possible access them through other objects. \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"var counterA = new Counter();\\nvar counterB = {};\\ncounterB.getCount = counterA.getCount;\\nconsole.log(counterB.getCount()) // logs the count of counterA\\n\")), mdx(\"p\", null, \"In this example, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"counterB\"), \" has access to the count of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"counterA\"), \" because it is given a reference to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getCount()\"), \" method, which has access to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"count\"), \" variable through the closure. \"));\n}\n;\nMDXContent.isMDXComponent = true;","fileAbsolutePath":"/home/lee/projects/gatsby/data-viz-portfolio/src/content/posts/javascript-environment-part-three.mdx","frontmatter":{"title":"The JavaScript Environment Part Three - Closures","date":"August 10, 2020"}}},"pageContext":{"id":"82149c5f-c3c7-5ede-9ea9-b1f07ffdd1b1"}}}