{"componentChunkName":"component---src-templates-mdx-index-js","path":"/posts/javascript-environment-part-four/","result":{"data":{"mdx":{"id":"f688fc4f-8756-5d37-a42e-bd4faabedfed","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"The JavaScript Environment Part Four - JavaScript Execution\",\n  \"date\": \"2020-08-11T00:00:00.000Z\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar Link = makeShortcode(\"Link\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This is part four of a six part series I\\u2019ve written to assist in my learning, and also to help anyone else out there facing similar struggles.\\nCheck out the other parts of this series:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(Link, {\n    to: \"/posts/javascript-environment-part-one\",\n    mdxType: \"Link\"\n  }, \"Overview\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(Link, {\n    to: \"/posts/javascript-environment-part-two\",\n    mdxType: \"Link\"\n  }, \"JavaScript Engines\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(Link, {\n    to: \"/posts/javascript-environment-part-three\",\n    mdxType: \"Link\"\n  }, \"Browser Engines\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"JavaScript Execution\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(Link, {\n    to: \"/posts/javascript-environment-part-five\",\n    mdxType: \"Link\"\n  }, \"Closures\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(Link, {\n    to: \"/posts/javascript-environment-part-six\",\n    mdxType: \"Link\"\n  }, \"Asynchronous Operations\"))), mdx(\"h2\", null, \"JavaScript Execution\"), mdx(\"p\", null, \"In this part I\\u2019ll explain the two phases of JavaScript execution:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The Identifier Resolution Phase\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The Execution Phase\")), mdx(\"p\", null, \"I\\u2019ll also discuss some important concepts related to this model.\"), mdx(\"h3\", null, \"Execution Phases\"), mdx(\"h4\", null, \"The Identifier Resolution Phase\"), mdx(\"p\", null, \"Remember, identifier resolution is the process of mapping (registering) identifiers (variable or function names) to variables (memory locations).\\nIn JavaScript, this process occurs every time a new lexical environment is created. \"), mdx(\"p\", null, \"Here\\u2019s an outline of the identifier resolution phase for a single lexical environment:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Create the Lexical Environment\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"If the environment is a function or global environment:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Scan the environment for function declarations:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Register the identifiers of function declarations that are outside other functions, and define their corresponding functions\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If an identifier already exists in the outer environment, overwrite it\"))))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Scan the environment for variable declarations:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If the environment is a block environment:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Register identifiers of variables declared with \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"let\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"const\"), \" in the current block, but do not initialize them\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If an identifier already exists in the outer environment, overwrite it\"))))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If the environment is a function or global environment:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Register the identifiers of variables declared with \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"var\"), \" outside other functions, and initialize them as \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"undefined\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If an identifier already exists in the current environment, overwrite it\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Register the identifiers of variables declared with \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"let\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"const\"), \" outside blocks, but do not initialize them\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If an identifier already exists in the current environment, throw a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"SyntaxError\"), \", as variables declared with \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"let\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"const\"), \" cannot be re-declared\")))))))), mdx(\"h5\", null, \"Variable Declarations\"), mdx(\"p\", null, \"If you follow the outline above, you\\u2019ll see why \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"const\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"let\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"var\"), \" work the way they do!\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"const\"), \": \", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"cannot be re-declared\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"cannot be reassigned\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"can be modified\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"must be initialized on definition\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"block, loop, function, or global scope\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"let\"), \": \", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"cannot be re-declared\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"can be reassigned\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"can be modified\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"block, loop, function, or global scope\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"var\"), \": \", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"can be re-declared\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"can be reassigned\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"can be modified\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"function or global scope\")))), mdx(\"h5\", null, \"A Note on \\u201CUndeclared Variables\\u201D\"), mdx(\"p\", null, \"From time to time I became confused when I found references to \\u201CUndeclared Variables\\u201D on Stack Overflow.\\nPeople call them undeclared because it looks like they were never registered with any variable declaration:\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo = null\")), mdx(\"p\", null, \"But thats actually not whats happening at all! These variables are being created as properties of the global object, which is defined by the global Environmental Record.\"), mdx(\"h4\", null, \"The Execution Phase\"), mdx(\"p\", null, \"Once the identifier resolution phase is complete, the execution phase begins and JavaScript code is executed line by line.\"), mdx(\"h3\", null, \"Important Concepts\"), mdx(\"h5\", null, \"Hoisting\"), mdx(\"p\", null, \"So the identified resolution phase registers variables and function declarations before the execution phase. Whats the big deal?\\nActually, this simple concept causes some very unexpected results. \"), mdx(\"p\", null, \"Any time you\\u2019ve heard someone mentioned \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"hoisting\"), \",\\nthis is what they\\u2019re talking about! People say this because in JavaScript, variables declared with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"var\"), \" and function declarations can be accessed before their declarations.\\nIt\\u2019s as if they are being \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"hoisted\"), \" to the top of the environment. And to add to the confusion, variables declared with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"let\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"const\"), \" cannot be accessed.\\nTrying to do so results in a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Reference Error\"), \"! This is why you sometimes see people saying that variables declared with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"let\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"const\"), \" are not hoisted.\"), mdx(\"p\", null, \"So what causes these two different behaviors?\"), mdx(\"p\", null, \"Well, variables delcared with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"var\"), \" are initialized as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \" on their registration and function declarations are defined on registration.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"console.log(foo); // logs the function\\nconsole.log(bar); // logs undefined\\n\\nfunction foo() {};\\nvar bar = null;\\n\")), mdx(\"p\", null, \"In this example, both \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"bar\"), \" can be accessed before their declaration. \"), mdx(\"p\", null, \"Unlike variables declared with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"var\"), \", variables declared with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"let\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"const\"), \" are never initialized as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \" on registration;\\nthey are left uninitialized until the execution phase. When accessed early, they throw a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Reference Error\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"console.log(foo); // throws a reference error\\nconsole.log(bar); // throws a reference error\\n\\nconst foo = null;\\nlet bar = null;\\n\")), mdx(\"p\", null, \"Why the sudden inconsistency??\"), mdx(\"p\", null, \"ECMAScript standards explicitly state \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.ecma-international.org/ecma-262/#sec-let-and-const-declarations\"\n  }), \"let and const\"), \"\\n\\u201Cmay not be accessed in any way until the variable\\u2019s LexicalBinding is evaluated.\\u201D\"), mdx(\"p\", null, \"This restriction results in a zone between the declaration of variables declared with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"let\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"const\"), \"\\nand the top of the environment which is known as the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Temporal Dead Zone\"), \" (TDZ). \"), mdx(\"p\", null, \"The TDZ exists to ensure variables declared with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"const\"), \" cannot be mutated as variables declared with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"var\"), \" can,\\nbecause this would violate their entire purpose. Variables declared with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"let\"), \" only have the TDZ for consistency, since both are block scoped.\"), mdx(\"p\", null, \"Feel free to go back and reference the outline of the identifier resolution phase from earlier, or just test any of this in a console if you don\\u2019t believe me.\"), mdx(\"h5\", null, \"Overriding Function Declarations\"), mdx(\"p\", null, \"Alright so this is another really strange one. You\\u2019re probably going to need the outline to follow along.\"), mdx(\"p\", null, \"Variables declared with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"var\"), \" are only initialized as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \" in step three of the identifier resolution process if they have not been encountered in the environment.\\nIf a variable is declared with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"var\"), \" but has the same identifier as a function declaration,\\nthe variable will already have been encountered because function declarations are registered before variables in step two of the identifier resolution process.\\nAs a result, the variable will not be initialized as undefined; instead, it will retain its value, the function, until the variable is re-initialized. \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"console.log(foo); // logs the function\\nvar foo = null;\\nfunction foo(){}\\nconsole.log(foo); // logs null\\n\")), mdx(\"p\", null, \"In this example, the identifier \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo\"), \" is registered and assigned a reference to a function declaration in step two of the identifier resolution process.\\nIn step three, it is not set to undefined because the identifier \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo\"), \" already exists in the environment;\\ninstead, it is left with the function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo\"), \" assigned as its reference until it is re-initialized by the var declaration.\\nThis reassignment causes the function declaration\\u2019s reference to be lost, and thus overridden. \"), mdx(\"p\", null, \"This same behavior can be accomplished by simply re-initializing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"console.log(foo); // logs the function\\nfoo = null;\\nfunction foo(){}\\nconsole.log(foo); // logs null\\n\")), mdx(\"p\", null, \"But not by re-declaring \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo\"), \": \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"console.log(foo); // logs the function\\nvar foo;\\nfunction foo(){}\\nconsole.log(foo); // logs the function\\n\")), mdx(\"p\", null, \"Because the identifier \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo\"), \" is never re-initialized, it retains its reference to the function declaration and is not overridden. \"), mdx(\"p\", null, \"Function declarations can only be overridden with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"var\"), \" or by simply re-initializing the identifier.\\nUsing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"let\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"const\"), \" will result in a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SyntaxError\"), \" because \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"let\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"const\"), \" cannot be re-declared from any other variable. \"), mdx(\"p\", null, \"No wonder some people hate JavaScript.\\nBut hey, not to worry, now you\\u2019ll never be confused about this again because I\\u2019m sure you\\u2019ve memorized the outline of the identifier resolution phase by now.\"), mdx(\"h5\", null, \"Is JavaScript Compiled or Interpreted?\"), mdx(\"p\", null, \"JavaScript is an interpreted language. \\u2026Or at very least its definitely not a compiled language in the traditional sense.\"), mdx(\"p\", null, \"Many interpreters use hybrid optimization techniques like Just In Time (JIT) Compilation.\\nBut this does not change the simple fact that JavaScript engines must have two distinct consecutive execution phases,\\npreventing JavaScript code from being compiled into a single binary file.\"));\n}\n;\nMDXContent.isMDXComponent = true;","fileAbsolutePath":"/home/lee/projects/gatsby/data-viz-portfolio/src/content/posts/javascript-environment-part-four.mdx","frontmatter":{"title":"The JavaScript Environment Part Four - JavaScript Execution","date":"August 11, 2020"}}},"pageContext":{"id":"f688fc4f-8756-5d37-a42e-bd4faabedfed"}}}